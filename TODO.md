# TODO

## Done

### [x] **CoreAudioClock** (macOS-only)
**Priority: Medium** - Synchronization and timing services

**What it provides:**
- Audio/MIDI synchronization
- SMPTE timecode support
- MIDI Time Code (MTC) and MIDI beat clock
- Tempo maps and time conversions
- Clock sources (audio devices, host time, external sync)

**Relevance:** Essential for DAWs, sequencers, and sync-dependent applications. Overlaps partially with MusicPlayer tempo functionality but provides broader sync capabilities.



## Missing/Unwrapped APIs

### [ ] **AudioWorkInterval** (macOS 10.16+, iOS 14.0+)
**Priority: Medium-Low** - Advanced feature for realtime workgroup management

**What it provides:**
- OS workgroup creation for realtime audio threads
- Thread deadline coordination across processes
- CPU usage optimization for power vs. performance

**Relevance:** Highly specialized - needed only for advanced audio apps creating custom realtime threads. Most apps use device-owned workgroups automatically.

**Recommendation:** Low priority - niche use case for professional audio developers.

---

### [ ] **AudioHardwareTapping** (macOS 14.2+)
**Priority: Low** - Recent addition, Objective-C only

**What it provides:**
- Process audio tapping (capture audio from other processes)
- Requires Objective-C (`CATapDescription` class)

**Relevance:** Very specialized - audio monitoring/routing utilities, system-wide audio capture.

**Recommendation:** Low priority - requires Objective-C bridge, limited applicability.

---

### [ ] **CAFFile Data Structures**
**Priority: Low** - Informational only

**What it provides:**
- Core Audio Format (CAF) file chunk definitions
- CAF header structures

**Relevance:** Informational header - actual CAF file I/O is already handled by `AudioFile` API. Adding these structures would only help developers parsing CAF files manually (rare).

**Recommendation:** Very low priority - no functional gap.

---

### [ ] **AudioCodec Component API**
**Priority: Low-Medium** - Low-level codec interface

**What it provides:**
- Direct codec component management
- Custom encoder/decoder control
- Packet-level audio translation

**Relevance:** Very low-level API. Most use cases covered by `AudioConverter` (higher-level) and `ExtendedAudioFile` (even higher-level). Direct codec access needed only for custom codec implementations or highly specialized workflows.

**Recommendation:** Low priority - `AudioConverter` covers 95% of use cases.

---

## Enhancement Opportunities

### [ ] **Performance Optimizations**
**Priority: MEDIUM-LOW**

**Current state:** Already using Cython for performance.

**Potential improvements:**
```python
# Memory-mapped file reading for very large files
audio = cm.AudioFile("huge_file.wav", mode='mmap')

# Zero-copy NumPy array views
data = audio.read_frames_view()  # Returns view, not copy

# Parallel processing utilities
cm.AudioFile.batch_process_parallel(
    files=["1.wav", "2.wav", ...],
    processor=my_processing_func,
    num_workers=4
)
```

**Benefits:**
- Better performance for large files
- Reduced memory footprint
- Faster batch operations

**Implementation Effort:** Medium - requires careful memory management

---

### [ ] **Plugin/Extension System**
**Priority: LOW**

**What to add:**
```python
# User-defined AudioUnit-compatible effects
@cm.register_audio_unit(type='effect', subtype='custom')
class MyCustomReverb(cm.AudioUnit):
    def process(self, input_buffer, output_buffer, frame_count):
        # Custom DSP here
        pass

# Plugin discovery
available_plugins = cm.discover_audio_units(type='effect')
```

**Benefits:**
- Extensibility for advanced users
- Community-contributed effects
- Integration with third-party AudioUnits

**Implementation Effort:** High - requires AudioUnit host implementation

---

### **Packaging and Distribution**
**Priority: MEDIUM**

**Current state:** Builds from source.

**Improvements:**
- **PyPI distribution** with pre-built wheels for macOS
- **Conda package** for conda-forge
- **ARM64 optimization** for Apple Silicon
- **Universal2 binaries** (x86_64 + arm64)

**Benefits:**
- Easier installation (`pip install coremusic`)
- Broader reach
- No compilation required for end users

**Implementation Effort:** Medium - CI/CD setup for wheel building

---

## Prioritized Roadmap

### Foundation (Immediate)
1. [ ] **PyPI Distribution** - Pre-built wheels

### Advanced Features (6-12 months)
2. [ ] **CoreAudioClock** - Sync and timecode support (if user demand exists)
3. [ ] **Performance Optimizations** - Memory mapping, zero-copy, parallel processing
4. [ ] **Plugin System** - Custom AudioUnit registration (advanced users)

### Specialized (12+ months, optional)
5. [ ] **AudioWorkInterval** - For advanced realtime audio developers
6. [ ] **AudioCodec API** - Direct codec component access (niche)
7. [ ] **AudioHardwareTapping** - Process tapping (requires ObjC bridge)

---

## Final Recommendations

### Skip or Defer
- **AudioHardwareTapping** - Too specialized, requires ObjC
- **AudioCodec API** - Already covered by AudioConverter
- **CAFFile structures** - No functional value
